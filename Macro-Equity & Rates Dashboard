# macro_equity_curve_dashboard.py
import streamlit as st
import numpy as np
import pandas as pd
import plotly.graph_objects as go
from datetime import datetime
from fredapi import Fred
import os

# ---------------------------
# 1. FRED API setup for US Treasury yields
# ---------------------------
# Read API key from environment variable for security
# Use environment variable if present; otherwise use the provided key
FRED_API_KEY = os.getenv("FRED_API_KEY") or "2a04395bbb187ffed6d250fca06cab18"
if os.getenv("FRED_API_KEY"):
    st.info("Using FRED API key from environment variable.")
else:
    st.info("Using embedded FRED API key (from user input).")

fred = Fred(api_key=FRED_API_KEY)

# Fetch latest yields for 2y,5y,10y,30y
def get_base_curve():
    symbols = {"2Y": "DGS2", "5Y": "DGS5", "10Y": "DGS10", "30Y": "DGS30"}
    yields = {}
    today = datetime.today().date()
    for label, symbol in symbols.items():
        try:
            y = fred.get_series_latest_release(symbol)
        except Exception as e:
            st.error(f"Error fetching {symbol} from FRED: {e}")
            st.stop()

        # Extract a scalar if fred returns a Series/array
        if isinstance(y, pd.Series):
            if y.empty:
                st.error(f"FRED returned no data for {symbol}.")
                st.stop()
            val = y.iloc[-1]
        elif isinstance(y, (list, np.ndarray)):
            if len(y) == 0:
                st.error(f"FRED returned no data for {symbol}.")
                st.stop()
            val = y[-1]
        else:
            val = y

        try:
            yields[label] = float(val)
        except Exception as e:
            st.error(f"Could not convert FRED series for {symbol} to float: {e}")
            st.stop()
    return yields

base_curve = get_base_curve()

# ---------------------------
# 2. Streamlit Layout
# ---------------------------
st.set_page_config(page_title="Macro Equity Curve Simulator", layout="wide")
st.title("Macro Equity Curve Simulator")

# Sidebar Controls
st.sidebar.markdown("<h2 style='color:black;'>Yield Curve Controls</h2>", unsafe_allow_html=True)
portfolio_size = st.sidebar.number_input("Portfolio Size (USD mn)", value=100, min_value=1, step=1)
scenario_type = st.sidebar.selectbox("Scenario Type", ["Steepener", "Flattener", "Twist", "Butterfly", "Custom"])
shock_bps = st.sidebar.slider("Shock Magnitude (bps)", min_value=-200, max_value=200, value=0)

# Custom Scenario Toggle
if scenario_type == "Custom":
    custom_shocks = {}
    for tenor in ["2Y", "5Y", "10Y", "30Y"]:
        custom_shocks[tenor] = st.sidebar.slider(f"{tenor} Shock (bps)", -200, 200, 0)
else:
    custom_shocks = None

# ---------------------------
# 3. Compute Scenario Curves
# ---------------------------
tenors = ["2Y", "5Y", "10Y", "30Y"]
base_yields = np.array([base_curve[t] for t in tenors])

def compute_scenario_curve(base_yields, scenario, shock_bps, custom_shocks=None):
    scenario_yields = base_yields.copy()
    if scenario == "Steepener":
        scenario_yields[0] -= shock_bps / 100
        scenario_yields[-1] += shock_bps / 100
    elif scenario == "Flattener":
        scenario_yields[0] += shock_bps / 100
        scenario_yields[-1] -= shock_bps / 100
    elif scenario == "Twist":
        scenario_yields[1] += shock_bps / 100
        scenario_yields[2] -= shock_bps / 100
    elif scenario == "Butterfly":
        scenario_yields[0] -= shock_bps / 100
        scenario_yields[1] += shock_bps / 100
        scenario_yields[2] += shock_bps / 100
        scenario_yields[3] -= shock_bps / 100
    elif scenario == "Custom":
        for i, tenor in enumerate(tenors):
            scenario_yields[i] += custom_shocks[tenor] / 100
    scenario_yields = np.maximum(scenario_yields, 0.0)  # avoid negative yields
    return scenario_yields

scenario_yields = compute_scenario_curve(base_yields, scenario_type, shock_bps, custom_shocks)

# ---------------------------
# 4. Compute Risk Metrics
# ---------------------------
def duration(yields, tenors):
    weights = np.array([2,5,10,30])
    return np.sum(weights * yields)/np.sum(weights)

def dv01(yields, tenors):
    return duration(yields, tenors) * 0.0001 * portfolio_size * 1e6

def convexity(yields, tenors):
    return np.sum((np.array([2,5,10,30])**2) * yields)/np.sum([2,5,10,30])

dur = duration(scenario_yields, tenors)
dv01_val = dv01(scenario_yields, tenors)
conv = convexity(scenario_yields, tenors)

# ---------------------------
# 5. Display Risk Metrics
# ---------------------------
st.subheader("Risk & Macro Metrics")
col1, col2, col3 = st.columns(3)
col1.metric("Effective Duration", f"{dur:.2f}")
col2.metric("DV01", f"${dv01_val:,.0f}")
col3.metric("Convexity", f"{conv:.2f}")

# ---------------------------
# 6. Plot Base and Scenario Curves
# ---------------------------
fig = go.Figure()
fig.add_trace(go.Scatter(
    x=tenors,
    y=base_yields,
    mode='lines+markers',
    name="Base Curve",
    line=dict(color="blue", width=3)
))
fig.add_trace(go.Scatter(
    x=tenors,
    y=scenario_yields,
    mode='lines+markers',
    name=f"{scenario_type} Scenario",
    line=dict(color="red", width=3, dash="dash")
))
fig.update_layout(
    title="US Treasury Yield Curve",
    xaxis_title="Tenor",
    yaxis_title="Yield (%)",
    template="plotly_white"
)
st.plotly_chart(fig, use_container_width=True)

# ---------------------------
# 7. Curve Factor Decomposition & PnL Attribution
# ---------------------------
st.subheader("Curve Factor Decomposition")
factor_df = pd.DataFrame({
    "Tenor": tenors,
    "Base Yield": base_yields,
    "Scenario Yield": scenario_yields,
    "Yield Change (bps)": (scenario_yields - base_yields) * 100
})
st.dataframe(factor_df)

st.subheader("PnL Attribution (Hypothetical)")
pnl_df = pd.DataFrame({
    "Tenor": tenors,
    "Notional (mn USD)": portfolio_size,
    "PnL ($)": dv01_val * (scenario_yields - base_yields) * 100
})
st.dataframe(pnl_df)

