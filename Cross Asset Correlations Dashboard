import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from itertools import combinations

# -----------------------------
# Page Config
# -----------------------------
st.set_page_config(
    page_title="Cross-Asset Correlation Monitor",
    layout="wide"
)

st.title("Cross-Asset Correlation Anomaly Detector")

# -----------------------------
# Sidebar Controls
# -----------------------------
st.sidebar.header("Global Settings")

rolling_window = st.sidebar.slider(
    "Rolling Window (days)",
    min_value=20,
    max_value=252,
    value=60
)

z_threshold = st.sidebar.slider(
    "Z-Score Threshold",
    min_value=1.0,
    max_value=3.0,
    value=2.0,
    step=0.1
)

start_date = st.sidebar.date_input("Start Date", pd.to_datetime("2020-01-01"))
end_date = st.sidebar.date_input("End Date", pd.to_datetime("today"))

# -----------------------------
# Asset Universe
# -----------------------------
ASSETS = {
    "Equities": {
        "SPY": "SPY",
        "NASDAQ (QQQ)": "QQQ",
        "Dow (DIA)": "DIA",
        "FTSE (EWU)": "EWU",
        "Nikkei (EWJ)": "EWJ"
    },
    "Rates": {
        "Long Bonds (TLT)": "TLT",
        "7-10Y (IEF)": "IEF",
        "1-3Y (SHY)": "SHY"
    },
    "FX": {
        "DXY": "DX-Y.NYB",
        "EURUSD": "EURUSD=X",
        "USDJPY": "JPY=X"
    },
    "Commodities": {
        "Gold (GLD)": "GLD",
        "Oil (USO)": "USO"
    },
    "Volatility": {
        "VIX": "^VIX"
    }
}

# -----------------------------
# Data Loader
# -----------------------------
@st.cache_data
def load_prices(tickers, start, end):
    prices = pd.DataFrame()

    for name, ticker in tickers.items():
        df = yf.download(ticker, start=start, end=end, progress=False)
        if df.empty:
            continue

        if isinstance(df.columns, pd.MultiIndex):
            prices[name] = df["Close"].iloc[:, 0]
        else:
            prices[name] = df["Close"]

    return prices.pct_change().dropna()

# -----------------------------
# Tabs
# -----------------------------
tab1, tab2 = st.tabs(["Core Monitor", "Custom Pair Analyzer"])

# ============================================================
# TAB 1 — CORE MONITOR (UNCHANGED)
# ============================================================
with tab1:

    core_assets = {
        "Equities (SPY)": "SPY",
        "Rates (TLT)": "TLT",
        "FX (DXY)": "DX-Y.NYB",
        "Commodities (GLD)": "GLD",
        "Volatility (VIX)": "^VIX"
    }

    returns = load_prices(core_assets, start_date, end_date)

    pairs = [
        ("Equities (SPY)", "Rates (TLT)"),
        ("Equities (SPY)", "FX (DXY)"),
        ("Equities (SPY)", "Commodities (GLD)"),
        ("Equities (SPY)", "Volatility (VIX)")
    ]

    st.subheader("Rolling Correlations")

    alerts = []

    for a, b in pairs:

        corr = returns[a].rolling(rolling_window).corr(returns[b])
        mean, std = corr.mean(), corr.std()
        z = (corr - mean) / std

        if abs(z.iloc[-1]) > z_threshold:
            alerts.append((a, b, corr.iloc[-1], z.iloc[-1]))

        col1, col2 = st.columns([4, 1])

        with col1:
            fig = go.Figure()
            fig.add_trace(go.Scatter(
                x=corr.index,
                y=corr,
                line=dict(color="navy", width=2)
            ))

            fig.add_hline(y=mean, line=dict(dash="dash", color="gray"))
            fig.add_hline(y=mean + z_threshold * std, line=dict(dash="dot", color="red"))
            fig.add_hline(y=mean - z_threshold * std, line=dict(dash="dot", color="red"))

            fig.update_layout(
                title=f"{a} vs {b}",
                height=350,
                template="plotly_white"
            )

            st.plotly_chart(fig, use_container_width=True)

        with col2:
            date_input = st.text_input(
                "Check Date",
                key=f"{a}_{b}_date"
            )

            if date_input:
                try:
                    date = pd.to_datetime(date_input)
                    value = corr.loc[:date].iloc[-1]
                    st.metric("Corr", f"{value:.2f}")
                except:
                    st.write("Invalid date")

    st.subheader("Correlation Alerts")

    if alerts:
        for a, b, c, z in alerts:
            st.error(f"{a} vs {b} | Corr: {c:.2f} | Z: {z:.2f}")
    else:
        st.success("No dislocations detected.")

# ============================================================
# TAB 2 — CUSTOM PAIR ANALYZER (2 OR 3 ASSETS)
# ============================================================
with tab2:

    st.subheader("Custom Cross-Asset Analyzer")

    num_assets = st.radio(
        "Number of Assets",
        [2, 3],
        horizontal=True
    )

    selected_assets = {}

    cols = st.columns(num_assets)

    for i in range(num_assets):
        with cols[i]:
            asset_class = st.selectbox(
                f"Asset Class {i+1}",
                list(ASSETS.keys()),
                key=f"class_{i}"
            )
            asset_name = st.selectbox(
                f"Asset {i+1}",
                list(ASSETS[asset_class].keys()),
                key=f"asset_{i}"
            )
            selected_assets[asset_name] = ASSETS[asset_class][asset_name]

    returns = load_prices(selected_assets, start_date, end_date)

    if returns.shape[1] >= 2:

        st.markdown("### Rolling Correlations")

        for a, b in combinations(returns.columns, 2):

            corr = returns[a].rolling(rolling_window).corr(returns[b])
            mean, std = corr.mean(), corr.std()
            z = (corr - mean) / std

            col1, col2 = st.columns([4, 1])

            with col1:
                fig = go.Figure()
                fig.add_trace(go.Scatter(
                    x=corr.index,
                    y=corr,
                    line=dict(width=2)
                ))

                fig.add_hline(y=mean, line=dict(color="gray", dash="dash"))
                fig.add_hline(y=mean + z_threshold * std, line=dict(color="red", dash="dot"))
                fig.add_hline(y=mean - z_threshold * std, line=dict(color="red", dash="dot"))

                fig.update_layout(
                    title=f"{a} vs {b}",
                    height=350,
                    template="plotly_white"
                )

                st.plotly_chart(fig, use_container_width=True)

            with col2:
                date_input = st.text_input(
                    "Check Date",
                    key=f"{a}_{b}_custom_date"
                )

                if date_input:
                    try:
                        date = pd.to_datetime(date_input)
                        value = corr.loc[:date].iloc[-1]
                        st.metric("Corr", f"{value:.2f}")
                    except:
                        st.write("Invalid date")
